/*
	다이나믹 프로그래밍 Dynamic Programming

	큰 문제를 작은 문제로 나눠서 푸는 알고리즘
	Dynamic Programming의 다이나믹은 아무 의미가 없다.
	이 용어를 처음 사용한 1940년 Richard Bellman은 멋있어보여서 사용했다고 한다.

	두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.

	1. Overlapping Subproblem
	2. Optimal Substructure

	피보나치수 
	F0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 (n >= 2)

	문제: N번째 피보나치 수를 구하는 문제
	작은 문제: N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

	문제: N-1번째 피보나치 수를 구하는 문제
	작은 문제: N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제

	큰 문제와 작은 문제는 상대적이다.
	문제를 작은 문제로 쪼갤 수 있다.
*/

/*
	Optimal Substructure

	문제의 정답을 작은 문제의 정답에서 구할 수 있다.

	예시
	서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
	대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.

	문제: N번쟤 피보나치 수를 구하는 문제
	작은 문제: N-1번재 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제
	문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.

	Optimal Substructure를 만족한다면, 
	문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.

	10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
	9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
	...

	4번째 피보나치 수는 항상 같다.
*/

/*
	다이나믹 프로그래밍에서는 각 문제는 한 번만 풀어야 한다.
	Optimal Substructure를 만족하기 때문에,
	같은 문제는 구할 때마다 정답이 같다.
	따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.
	이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
	메모를 한다고 해서 영어로 Memoization이라고 한다.

	int fibonacci(int n) {
		if (n <= 1) {
			return n;
		}
		else {
			return fibonacci(n-1) + fibonacci(n-2);
		}
	}

	한 번 답을 구할 때, 어딘가에 메모를 해놓고,
	중복 호출이면 메모해놓은 값을 리턴한다.

	int memo[100];
	int fibonacci(int n) {
		if (n <= 1) {
			return n;
		}
		else {
			if (memo[n] > 0) {
				return memo[n];
			}
			memo[n] = fibonacci(n-1) + fibonacci(n-2);
			return memo[n];
		}
	}
*/

/*
	다이나믹을 푸는 두 가지 방법이 있다.

	1. Top-down
	2. Bottom-up
*/
/*
	Top-down
	
	1. 문제를 작은 문제로 나눈다.
	2. 작은 문제를 푼다.
	3. 작은 문제를 풀었으니, 이제 문제를 푼다.

	1. 문제를 풀어야 한다
		fibonacci(n)
	2. 문제를 작은 문제로 나눈다.
		fibonacci(n-1) + fibonacci(n-2)로 문제를 나눈다
	3. 작은 문제를 푼다
		fibonacci(n-1)과 fibonacci(n-2)를 호출해 문제를 푼다.
	4. 작은 문제를 풀었으니, 이제 문제를 푼다.
		fibonacci(n-1)의 값과 fibonacci(n-2)의 값을 더해 문제를 푼다.

	Top-down은 재귀 호출을 이용해서 문제를 쉽게 풀 수 있다.
*/
/*
	Bottom-up

	1. 문제를 크기가 작은 문제부터 차례대로 푼다.
	2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
	3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
	4. 그러다보면, 언젠가 풀어야 하는 문제를 풀 수 있다.

	int d[100];
	int fibonacci(int n) {
		d[0] = 1;
		d[1] = 1;
		for (int i=2; i<=n; i++) {
			d[i] = d[i-1] + d[i-2];
		}
		return d[n];
	}

	1. 문제를 크기가 작은 문제부터 차례대로 푼다.
		for (int i=2; i<=n; i++)
	2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
		for (int i=2; i<=n; i++)
	3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
		d[i] = d[i-1] + d[i-2];
	4. 그러다보면, 언젠가 풀어야 하는 문제를 풀 수 있다.
		d[n]을 구하게 된다.
*/

/*
	다이나믹 문제 풀이 전략

	문제를 구하려고 하는 답을 문장으로 나타낸다.
	예: 피보나치 수를 구하는 문제
	N번째 피보나치 수
	이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
	Top-down인 경우에는 재귀 호출의 인자의 개수
	문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현해야 한다.

	다이나믹 문제 풀이
	다이나믹은 문제를 많이 풀면서 감을 잡는 것이 중요하기 때문에
	문제를 폴어 보도록 하자.
*/

/*
	백준 문제

	1463 1로 만들기
	11726 2xn 타일링
	11727 2xn 타일링 2
	9095 1,2,3 더하기
	11052 카드 구매하기
	10844 쉬운 계단 수
	11057 오르막 수
	2193 이친수
	9465 스티커
	2156 포도주 시식
	11053 가장 긴 증가하는 부분 수열
	11055 가장 큰 증가하는 부분 수열
	11722 가장 긴 감소하는 부분 수열
	11054 가장 긴 바이토닉 부분 수열

	1912 연속합
	2579 계단 오르기
	1699 제곱수의 합
	2133 타일 채우기
	9461 파도반 수열
	2225 합분해
	2011 암호 코드
*/