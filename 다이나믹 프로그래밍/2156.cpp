/*
	2156 포도주 시식

	포도주가 일렬로 놓여져 있고, 다음과 같은 2가지 규칙을 지키면서
	포도주를 최대한 많이 마시려고 한다.
	
	1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고,
	마신 후에는 원래 위치에 다시 놓아야 한다.
	2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

	D[i] = A[1], ... , A[i] 까지 포도주를 마셨을 때,
	마실 수 있는 포도주의 최대 양

	i에게 가능한 경우
	1. i번째 포도주를 마시는 경우
		D[i-1] + A[i]
	2. i번째 포도주를 마시지 않는 경우
		D[i-1]
	D[i] = max(D[i-1]+A[i], D[i-1])
	위의 식은 포도주를 연속해서 3잔 마시면 안되는 경우를 처리하지 못한다.

	D[i][j] = A[1], ..., A[i] 까지 포도주를 마셨을 때,
	마실 수 있는 포도주의 최대 양, A[i]는 j번 연속해서 마신 포도주임

	D[i][0] = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
		max(D[i-1][0], D[i-1][1], D[i-1][2])
	D[i][1] = 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않았음
		D[i-1][0] + A[i]
	D[i][2] = 2번 연속해서 마신 포도주 -> 
		A[i-1]을 마시고, A[i-2]를 마시지 않았어야 함
		D[i-1][1] + A[i]

	다른 방법
	D[i] = A[1], ..., A[i]까지 포도주를 마셨을 때,
	마실 수 있는 포도주의 최대 양

	0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
		D[i-1]
	1번 연속해서 마신 포도주 -> A[i-1]을 마시지 않았음
		D[i-2] + A[i]
	2번 연속해서 마신 포도주 -> A[i-1]을 마시고, A[i-2]는 마시지 않았어야 함
		D[i-3] + A[i-1] + A[i]
	D[i] = max(D[i-1], D[i-2]+A[i], D[i-3]+A[i-1]+A[i])

	i-2, i-3 때문에 예외 처리가 예상되기 때문에
	D[1] = A[1]
	D[2] = A[1] + A[2]
	로 미리 처리를 해두고 i=3부터 문제를 푸는 것이 좋다.

	d[1] = a[1];
	d[2] = a[1] + a[2];
	for (int i=3; i<=n; i++) {
		d[i] = d[i-1];
		if (d[i] < d[i-2] + a[i]) {
			d[i] = d[i-2] + a[i];
		}
		if (d[i] < d[i-3] + a[i] + a[i-1]) {
			d[i] = d[i-3] + a[i] + a[i-1];
		}
	}
*/

#include <iostream>
using namespace std;
int a[10001];
int d[10001];
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	d[1] = a[1];
	d[2] = a[1] + a[2];
	for (int i = 3; i <= n; i++) {
		d[i] = d[i - 1];
		if (d[i] < d[i - 2] + a[i]) {
			d[i] = d[i - 2] + a[i];
		}
		if (d[i] < d[i - 3] + a[i] + a[i - 1]) {
			d[i] = d[i - 3] + a[i] + a[i - 1];
		}
	}
	printf("%d\n", d[n]);
	return 0;
}