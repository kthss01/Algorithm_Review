/*
	트리 Tree

	자료구조의 일종
	사이클이 없는 그래프
	정점의 개수: V
	간선의 개수: V-1

	Ex)
	중위 순회로 표현 {4,2,5,1,6,3,7}

	루트가 있는 트리 Rooted Tree
	1번이 루트
	루트부터 아래로 방향을 정할 수 있음

	부모 Parent
	1은 2의 부모
	2는 4의 부모
	2는 1의 자식
	4는 2의 자식
	3의 자식: 6,7

	단말 정점 Leaf Node
	4,5,6,7

	형제 Sibling
	4와 5는 형제
	6과 7은 형제
	2와 3은 형제
	같은 부모를 가지면 형제

	깊이 Depth
	루트에서부터 거리 (루트의 깊이를 0으로 하는 경우와 1로 하는 경우가 있다)

	높이 Height
	깊이 중 가장 큰 값 2 또는 3

	조상, 자손 Ancestor, Descendent
	p -> q로 갈 수 있을 때
	p가 q보다 루트에 가까우면
	p는 q의 조상
	q는 p의 자손

	이진 트리 Binary Tree
	자식을 최대 2개만 가지고 있는 트리
*/

/*
	트리의 표현 Representation of Tree

	트리는 그래프이기 때문에, 그래프의 표현과 같은 방식으로 저장할 수 있다.
	또는
	트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 
	부모만 저장하는 방식으로 저장할 수 있다.
	부모가 0개인 경우는 트리의 루트인데, 
	이 경우 부모를 -1이나 0으로 처리하는 방식을 사용한다.

	트리의 부모만 저장하는 방식
	ex)
	i		1	2	3	4	5	6	7
	p[i]	0	1	1	2	2	3	3

	이진 트리의 경우에는 배열로 표현할 수 있다.
	부모의 노드가 x인 경우에 자식의 노드는 2*x, 2*x+1로 나타내면 된다
	
	또는, A[i][0]에 i의 왼쪽 자식, A[i][1]에 i의 오른쪽 자식을 저장할 수 있다.
*/

/*
	트리의 순회 Tree Traversal

	트리의 모든 노드를 방문하는 순서
	그래프의 경우에는 DFS와 BFS가 있었다
	트리에서도 위의 두 방법을 사용할 수 있지만, 
	트리에서만 사용할 수 있는 세 방법이 있다.

	프리오더
		노드 방문
		왼쪽 자식 노드를 루트로 하는 서브 트리 프리오더
		오른쪽 자식 노드를 루트로 하는 서브 트리 프리오더

	인오더
		왼쪽 자식 노드를 루트로 하는 서브 프리 인오더
		노드 방문
		오른쪽 자식 노드를 루트로 하는 서브 트리 인오더

	포스트오더
		왼쪽 자식 노드를 루트로 하는 서브 트리 포스트오더
		오른쪽 자식 노드를 루트로 하는 서브 트리 포스트오더
		노드 방문

	ex)
	프리오더 Pre-order
	ABDECFG
	그래프의 DFS이 순서와 같다

	인오더 In-order
	DBEAFCG
	{4,2,5,1,6,3,7}

	포스트오더 Post-order
	DGEBFCA

	세 방법의 차이는 노드 방문을 언제하냐의 차이
*/
/*
	백준 문제
	1991 트리 순회
*/

/*
	트리의 탐색

	BFS

	트리의 탐색은 DFS/BFS 알고리즘을 이용해서 할 수 있다.
	트리는 사이클이 없는 그래프이기 때문에
	임의의 두 정점 사이의 경로는 1개이다.
	따라서, BFS 알고리즘을 이용해서 최단 거리를 구할 수 있다.
	이유: 경로가 1개라 찾은 그 경로가 최단 경로
*/
/*
	백준 문제

	11725 트리의 부모 찾기
*/

/*
	트리의 지름 Diamater

	트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라고 한다
	트리의 지름은 탐색 2번으로 구할 수 있다.
	
	1. 루트에서 모든 정점까지의 거리를 구하나. 이 때, 가장 먼 거리였던 정점을 A라고 한다.
	2. A를 루트라고 하고 모든 정점까지의 거리를 구한다. 이 때 구한 가장 먼 거리가 지름이다.
*/
/*
	백준 문제

	1167 트리의 지름
	1967 트리의 지름
*/