/*
	순열 Permutation

	1 ~ N 까지로 이루어진 수열
	1 2 3
	4 1 3 2
	5 4 2 3 1
	6 5 1 2 3 4
	크기는 항상 N이 되어야 하고, 겹치는 숫자가 존재하지 않음

	크기가 N인 순열은 총 N!개가 존재한다
	순열을 사전순으로 나열했을 대
	N = 3인 경우에 사전순은 다음과 같다
	1 2 3
	1 3 2
	2 1 3
	2 3 1
	3 1 2
	3 2 1
*/

/*
	다음 순열 Next Permutation

	순열을 사전순으로 나열했을 때, 사전순으로 다음에 오는 순열과
	이전에 오는 순열을 찾는 방법
	C++ STL의 algorithm에는 이미 next_permutation과 prev_permutation이
	존재하기 때문에 사용하면 된다.

	A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다.
	j >= i이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾는다.
	A[i-1]과 A[j]를 swap한다
	A[i]부터 순열을 뒤집는다

	순열 7 2 3 6 5 4 1

	A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다
	즉, 순열의 마지막 수에서 끝나는 가장 큰 긴 감소수열을 찾아야 한다.
	순열: 7 2 3_ 6 5 4 1

	j >= i이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾는다
	7 2 3_ 6 5 4__ 1

	A[i-1]과 A[j]를 swap한다
	순열: 7 2 4__ 6 5 3_ 1

	A[i]부터 순열을 뒤집는다
	순열: 7 2 4__ 1 3 5 6

	bool next_permutation(int* a, int n) {
		int i = n-1;
		while (i > 0 && a[i-1] >= a[i]) i -= 1;
		if (i <= 0) return false; // 마지막 수열
		int j = n-1;
		while (a[j] <= a[i-1]) j -= 1;
		swap(a[i-1], a[j]);
		j = n-1;
		while (i < j) {
			swap(a[i], a[j]);
			i += 1; j -= 1;
		}
		return true;
	}
*/
/*
	백준 문제
	10972 다음 순열
	10973 이전 순열
	10974 모든 순열
	1722 순열의 순서
*/