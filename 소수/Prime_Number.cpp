/*
	소수 Prime Number

	소수: 약수가 1과 자기 자신 밖에 없는 수
	N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로
	나누어 떨어지면 안된다.
	1부터 100까지 소수
	2,3,5,7,11,13,17,19,23,29,31,37,41,43,
	47,53,59,61,67,71,73,79,83,89,97

	bool prime(int n) {
		if (n < 2) {
			return false;
		}
		for (int i=2; i<=n-1; i++) {
			if (n % i == 0) {
				return false;
			}
		}
		return true;
	}

	소수: 약수가 1과 자기 자신 밖에 없는 수
	N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로
	나누어 떨어지면 안된다.
	이유: N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문
	N = a X b로 나타낼 수 있는데, a가 작을수록 b는 크다.
	가능한 a중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않는다.

	bool prime(int n) {
		if (n < 2) {
			return false;
		}
		for (int i=2; i<=n/2; i++) {
			if (n % i == 0) {
				return false;
			}
		}
		return true;
	}

	소수: 약수가 1과 자기 자신 밖에 없는 수
	N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로
	나누어 떨어지면 안된다.
	이유:N이 소수가 아니라면, N = a x b로 나타낼 수 있다. (a <= b)
	a > b라면 두 수를 바꿔서 항상 a <= b로 만들 수 있다.
	두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.
	따라서, 루트 N까지만 검사를 해보면 된다.

		bool prime(int n) {
		if (n < 2) {
			return false;
		}
		for (int i=2; i*i<=n; i++) {
			if (n % i == 0) {
				return false;
			}
		}
		return true;
	}

	컴퓨터에서는 실수는 근사값을 나타내기 때문에, 루트 N과 같은 경우는
	위에처럼 나타내는 것이 좋다.
	루트 i <= N은
	i <= N*N과 같다.
	어떤 수 N이 소수인지 아닌지 판별하는데 걸리는 시간 복잡도: O(루트 N)
*/
/*
	백준 문제
	1978 소수 찾기
*/

/*
	소수 Prime Number

	어떤 수 N이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 O(루트 N)이었다.
	N이 백만인 경우: 루트 N = 1,000
	N이 1억인 경우: 루트 N = 10,000
	그럼, 1부터 1,000,000까지 모든 소수를 구하는데 걸리는 시간 복잡도는 몇일까?
	각각의 수에 대해서 소수인지 아닌지 검사해야 한다.
	각각의 수에 대해서 O(루트 N)의 시간이 걸린다.
	수는 총 N개이기 때문에, O(N루트N)이 걸린다.
	1,000,000 * 1,000 = 1,000,000,000 = 10억 = 10초
	너무 긴 시간이 필요하다.

	에라토스테네스의 체 Sieve of Eratosthenes

	1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.
	2부터 N까지 모든 수를 써놓는다.
	아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
	그 수는 소수이다.
	이제 그 수의 배수를 모두 지운다.

	지워지지 않는 수 중에서 가장 작은 수는 2이다.
	2는 소수이고 2의 배수를 모두 지운다.
	3의 배수를 지운다.
	5의 배수를 지운다.
	7의 배수를 지운다.
	11의 배수는 이미 지워져 있다.
	2,3,5,7로 인해서
	11X11은 121로 100을 넘기 때문에 
	더 이상 수행할 필요가 없다.
	남아있는 모든 수가 소수이다.

	int p[100]; // 소수 저장
	int pn = 0; // 소수의 개수
	bool c[101]; // 지워졌으면 true
	int n = 100; // 100까지 소수
	for (int i=2; i<=n; i++) {
		if(c[i] == false) {
			p[pn++] = i;
			for (int j = i*i; j<=n; j+=i) {
				c[j] = true;
			}
		}
	}

	1부터 N까지 모든 소수를 구하는 것이 목표이기 때문에, 구현할 때는 
	바깥 for문 (i)를 N까지 돌린다.
	안쪽 for문 (j)는 N의 크기에 따라서, i*i 또는 i*2로 바꾸는 것이 조하.
	i = 백만인 경우 i*i는 범위를 넘어가기 때문
*/
/*
	백준 문제
	1929 소수 구하기
*/

/*
	골드바흐의 추측 Goldbach's conjecture

	2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
	위의 문장에 3을 더하면
	5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다로 바뀐다.
	아직 증명되지 않은 문제
	10^18이하에서는 참인 것이 증명되어 있다.
*/
/*
	백준 문제
	6588 골드바흐의 추측
*/