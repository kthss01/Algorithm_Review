/*
	비트마스크 Bitmask

	비트(bit) 연산을 사용해서 부분 집합을 표현할 수 있다.
*/

/*
	비트 연산 bitwise operation

	&(and), |(or), ~(not), ^(xor)

	두 수 A와 B를 비트 연산 하는 경우에는 
	가장 뒤의 자리부터 하나씩 연산을 수행하면 된다.

	A = 27, B = 83인 경우
	A = 11011, B = 1010011
	A & B = 19, A | B = 91, A ^ B = 73

	not 연산의 경우에는 자료형에 따라 결과가 달라진다.
	
	A = 83 = 1010011
	~A = 10101100 (8비트 자료형인 경우)
	~A = 11111111 11111111 11111111 10101100 (32비트 자료형인 경우)
	또, unsinged, singed에 따라서 보여지는 값이 다르다.

	shift left (<<)와 shift right (>>) 연산이 있다.
	A << B (A를 왼쪽으로 B비트만큼 민다.

	1 << 0 = 1
	1 << 1 = 2 (10)
	1 << 2 = 4 (100)
	1 << 3 = 8 (1000)
	1 << 4 = 16 (10000)
	3 << 3 = 24 (11000)
	5 << 10 = 5120 (1010000000000)

	1 >> 0 = 1
	1 >> 1 = 0 (0)
	10 >> 1 = 5 (101)
	10 >> 2 = 2 (10)
	10 >> 3 = 1 (1)
	30 >> 1 = 15 (1111)
	1024 >> 10 = 1 (1)

	A << B는 A X 2^B와 같다.
	A >> B는 A / 2^B와 같다.

	(A + B) / 2 (A + B) >> 1로 쓸 수 있다.
	어떤 수가 홀수 인지 판별하는 if (N % 2 == 1) 은 
	if (N & 1)로 줄여 쓸 수 있다.
*/

/*
	비트 마스크 Bitmask

	정수로 집합을 나타낼 수 있다.
	{1, 3, 4, 5, 9} = 570 = 2^1 + 2^3 + 2^4 + 2^5 + 2^9

	0이 포함되어 있는지 검사
		570 & 2^0 = 570 & (1 << 0) = 0
	1이 포함되어 있는지 검사
		570 & 2^1 = 570 & (1 << 1) = 2
	2가 포함되어 있는지 검사
		570 & 2^2 = 570 & (1 << 2) = 0
	3이 포함되어 있는지 검사
		570 & 2^3 = 570 & (1 << 3) = 8

	1 추가하기
		570 | 2^1 = 570 + (1 << 1) = 570 (1000111010)
	2 추가하기
		570 | 2^2 = 570 + (1 << 2) = 574 (1000111110)
	3 추가하기
		570 | 2^3 = 570 + (1 << 3) = 570 (1000111010)
	4 추가하기
		570 | 2^4 = 570 + (1 << 4) = 574 (1000111010)

	1 제거하기
		570 & ~2^1 = 570 + ~(1 << 1) = 568 (1000111000)
	2 제거하기
		570 & ~2^2 = 570 + ~(1 << 2) = 570 (1000111010)
	3 제거하기
		570 & ~2^3 = 570 + ~(1 << 3) = 562 (1000110010)
	4 제거하기
		570 & ~2^4 = 570 + ~(1 << 4) = 546 (1000101010)

	전체 집합
		1 << N - 1
	공집합
		0

	현재 집합이 S일 떄

	i를 추가
		S | (1 << i)
	i를 검사
		S & (1 << i)
	i를 제거
		S & ~(i << i)
	i를 토글 (0을 1로, 1을 0으로)
		S ^ (1 << i)
*/
/*
	백준 문제
	11723 집합
*/

/*
	비트마스크 Bitmask

	물론 배열을 사용하는 것이 더욱 편리하지만, 비트마스크를 사용하는 이유는
	집합을 배열의 인덱스로 표현할 수 있기 때문이다.
	상태 다이나믹을 할 때 자주 사용하게 된다.
*/

/*
	bitset bitset

	비트마스크는 STL의 bitset을 이용해서 더 쉽게 나타낼 수 있다.
*/